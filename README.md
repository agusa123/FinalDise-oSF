El patrón seleccionado es Observer, ya que ofrece una solución eficiente y estructurada para notificar automáticamente a múltiples observadores cuando ocurre un cambio en el estado del sujeto. Este patrón es especialmente útil en situaciones donde es necesario mantener la consistencia entre un objeto principal y sus dependientes, evitando que los observadores tengan que consultar constantemente el estado del sujeto.

Una de las principales ventajas de Observer es su capacidad para gestionar de manera sencilla las suscripciones y cancelaciones de los observadores, proporcionando una gran flexibilidad al sistema. Esto resulta ideal en un contexto dinámico donde los observadores (por ejemplo, componentes de interfaz gráfica, sistemas de reportes, etc.) pueden entrar o salir de la relación según sea necesario.

Además, el patrón Observer establece una relación uno-a-muchos entre el sujeto y los observadores. Esto significa que un único cambio en el estado del sujeto puede ser reflejado de forma inmediata y simultánea en todos los observadores asociados. Este enfoque centralizado evita duplicidad de lógica y asegura que todos los observadores reciban la información actualizada de manera consistente y sincronizada.

Por estas razones, el patrón Observer no solo es adecuado, sino óptimo para resolver esta situación problema, ya que garantiza una comunicación eficiente entre los objetos del sistema, facilita la extensibilidad y mantiene un diseño desacoplado entre el sujeto y los observadores.
